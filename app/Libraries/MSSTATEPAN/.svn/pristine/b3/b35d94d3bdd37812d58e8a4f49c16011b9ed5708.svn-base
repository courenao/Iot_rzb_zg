/*
  V0.1 Initial Release   10/July/2006  RBR

*/

#include "hal.h"
#include "halstack.h"
#include "evboard.h"
#include "evbConfig.h"



EVB_SW_STATE sw_state;


#define SW_POLL_TIME   MSECS_TO_MACTICKS(100)

//only one switch input
void evbIntCallback(void){
//poll the switches
 sw_state.bits.s1_last_val = sw_state.bits.s1_val;
 sw_state.bits.s1_val = !(SW1_INPUT_VALUE()); //low true switch, so invert
 if (sw_state.bits.s1_last_val != sw_state.bits.s1_val) {
       sw_state.bits.s1_tgl = 1;
 }

 }


UINT32 last_switch_poll;
//poll the switches
void evbPoll(void){

//only do this if the slow timer not enabled as reading
//the joystick takes a while. If the slowtimer is enabled,
//then that interrupt is handing polling
#ifndef LRWPAN_ENABLE_SLOW_TIMER
  if ( halMACTimerNowDelta(last_switch_poll) > SW_POLL_TIME) {
   evbIntCallback();
   last_switch_poll = halGetMACTimer();
  }
#endif

}

//init the board
void evbInit(void){
  halInit();
  SW_CONFIG();
  sw_state.val = 0;
  INIT_LED1();
  INIT_LED2();
}

void evbLedSet(BYTE lednum, BOOL state) {
    switch(lednum) {
       case 1:    if (state) LED1_ON(); else LED1_OFF(); break;
       case 2:    if (state) LED2_ON(); else LED2_OFF(); break;
    }
}

BOOL evbLedGet(BYTE lednum){
  switch(lednum) {
       case 1:    return(LED1_STATE());
       case 2:    return(LED2_STATE());
    }
  return(FALSE);
}


