/*
  V0.1 Initial Release   10/July/2006  RBR

*/

#include "hal.h"
#include "halStack.h"
#include "console.h"
#include "debug.h"
#include "ieee_lrwpan_defs.h"
#include "memalloc.h"
#include "phy.h"
#include "mac.h"
#include "MCR20Reg.h"
#include "MCR20Drv.h"
#include "MCR20A_Phy.h"


//debug
#include "evboard.h"

#define MKL46Z_BOARD 1
#if MKL46Z_BOARD
#include "Gpio_IrqAdapter.h"

void RADIO_IRQ_Handler();
void IRQ_Handler();

void MCR20A_InstallIsr()
{
    GpioInstallIsr(IRQ_Handler, gGpioIsrPrioHigh_c, 0xC0, kGpioXcvrIrq);
}

#else
void MCR20A_InstallIsr()
{
}

#endif

#define MCR20A_PAN   0  //PAN0或PAN1，MCR20A具有双PAN功能


static volatile RADIO_FLAGS local_radio_flags;  //记录射频模块工作模式状态
static volatile PHY_FREQ_ENUM freq_pre;      //记录功能
static volatile BYTE channel_pre;

BYTE rxWaterMark;
#define RX_TIMEOUT   2000 //接收时序超时值,T3每16us一次计数，16us*1500=24ms

phyTime_t count = 0;    //计数器，用于控制LED显示

typedef struct {
    BYTE seq: 1;
    BYTE tx: 1;
    BYTE rx: 1;
    BYTE cca: 1;
    BYTE rxWaterMark: 1;
    BYTE filterFail: 1;
    BYTE pllUnlock: 1;
    BYTE rxFramePend: 1;
} irq_t;
irq_t irq;


#ifdef  LRWPAN_ASYNC_INTIO  //异步数据收发，采用缓冲处理

static volatile BYTE serio_rxBuff[LRWPAN_ASYNC_RX_BUFSIZE];
static volatile BYTE serio_rxHead, serio_rxTail;

#endif

static BYTE random_seeded;

/*---------------------------------------------------------------------------
* @名称: halInit
* @概述: 初始化硬件设备
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/
void halInit(void)
{
    //Set clock source
    local_radio_flags.val = 0;
    random_seeded = 0;



    //初始化硬件，初始化成MCR20A_PAN
    MCR20A_HwInit(MCR20A_PAN);
    //SET_MAIN_CLOCK_SOURCE(CRYSTAL);
    halInitUart();
    //halSetBaud(LRWPAN_DEFAULT_BAUDRATE);
    halInitMACTimer();
}

/*---------------------------------------------------------------------------
* @名称: halInitUart
* @概述: 初始化UART设备
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/
void halInitUart(void)
{


#ifdef LRWPAN_ASYNC_INTIO
    serio_rxHead = 0;
    serio_rxTail = 0;
    //开启串口中断
    //INT_ENABLE_URX0(INT_ON);
#endif

}

#ifdef  LRWPAN_ASYNC_INTIO


/*---------------------------------------------------------------------------
* @名称: halGetch
* @概述: (缓冲方式)从串口中获取一个字节的数据
*        (异步方式，直接读缓冲器，数据来源于中断服务)
*        缓冲器采用循环结构，读取到了最尾部后再重新回到头。
* @输入: 无
* @输出: char型数据
* @备注: 该模块函数与任何硬件无关，可以直接移植。
*---------------------------------------------------------------------------*/
char halGetch(void)
{
    char x;
    do {
        x = serio_rxHead;  //use tmp because of volt decl
    }  while(serio_rxTail == x);
    serio_rxTail++;
    if (serio_rxTail == LRWPAN_ASYNC_RX_BUFSIZE) serio_rxTail = 0;
    return (serio_rxBuff[serio_rxTail]);
}

/*---------------------------------------------------------------------------
* @名称: halInitUart
* @概述: (缓冲方式)UART是否有数据可读状态。
*        只要当前缓冲的头标志跟尾部标志不等即认为缓冲有数据。
* @输入: 无
* @输出: BOOL型状态
* @备注: 该模块函数与任何硬件无关，可以直接移植。
*---------------------------------------------------------------------------*/
BOOL halGetchRdy(void)
{
    char x;
    x = serio_rxHead;
    return(serio_rxTail != x);
}

#else

/*---------------------------------------------------------------------------
* @名称: halGetch
* @概述: (直接读取)从串口中获取一个字节的数据
* @输入: 无
* @输出: char型数据
* @备注:
*---------------------------------------------------------------------------*/
char halGetch(void)
{
    char c;

    return c;
}

/*---------------------------------------------------------------------------
* @名称: halGetchRdy
* @概述: (直接读取)UART是否有数据可读状态。
* @输入: 无
* @输出: BOOL型状态
* @备注:
*---------------------------------------------------------------------------*/
BOOL halGetchRdy(void)
{
    BOOL ret = 0;

    return ret;
}

#endif


/*---------------------------------------------------------------------------
* @名称: halUtilMemCopy
* @概述: 内存拷贝
* @输入: 无
* @输出: 无
* @备注: 该模块函数与任何硬件无关，可以直接移植。
*---------------------------------------------------------------------------*/
void halUtilMemCopy(BYTE *dst, BYTE *src, BYTE len)
{
    while (len) {
        *dst = *src;
        dst++;
        src++;
        len--;
    }
}

// assuming 16us period, have 1/16us = 62500 tics per seocnd
#define T2CMPVAL (62500/SLOWTICKS_PER_SECOND)


/*---------------------------------------------------------------------------
* @名称: halInitMACTimer
* @概述: 初始化MAC时钟
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/
void halInitMACTimer(void)
{


}

/*---------------------------------------------------------------------------
* @名称: halGetMACTimer
* @概述: 获取MAC时钟
*        获取MCR20A的时间值，用于计算CCA
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/
UINT32 halGetMACTimer(void)
{
    return MCR20A_GetMACTimer();
}

#ifdef LRWPAN_COMPILER_NO_RECURSION

/*---------------------------------------------------------------------------
* @名称: halISRGetMACTimer
* @概述: 中断获取MAC时钟
*        获取MCR20A的时间值，用于计算CCA
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/

UINT32 halISRGetMACTimer(void)
{
    return MCR20A_GetMACTimer();
}

#endif




/*---------------------------------------------------------------------------
* @名称: halMacTicksToUs
* @概述: 计算一个us需要的Ticks数
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/
UINT32 halMacTicksToUs(UINT32 ticks)
{

    UINT32 rval;
    //ticks/SYMBOLS_PER_MAC_TICK *16
    rval =  (ticks / SYMBOLS_PER_MAC_TICK()) * (1000000 / LRWPAN_SYMBOLS_PER_SECOND);
    return(rval);
}


/*---------------------------------------------------------------------------
* @名称: halGetRandomByte
* @概述: 获取一个字节的随机数
* @输入: 无
* @输出: UINT8型的随机数
* @备注:
*---------------------------------------------------------------------------*/
UINT8 halGetRandomByte(void)
{
    UINT8 byte = 0;
    UINT32 u32 = 0; //存储32位数据

#if MCR20A_RNG_ENABLE   //使用MCR20A芯片自带的RNG发生器，建议不开启

    MCR20A_GetRandomNo((uint32_t *)&u32);
#else   //使用STM32_CPU 的RNG随机数发生器，能有效提高效率

    while(RNG_GetFlagStatus(RNG_FLAG_DRDY) == RESET);  //等待随机数准备完毕
    u32 = RNG_GetRandomNumber();  //读数

#endif

    byte = (UINT8)u32; //截取8位数据
    return(byte);
}

/*---------------------------------------------------------------------------
* @名称: halPutch
* @概述: 串口写一个字节的数
* @输入: char型数据
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/

void halPutch(char c)
{

}

/*---------------------------------------------------------------------------
* @名称: halRawPut
* @概述: 串口写一个字节的数(与halPutch等同)
* @输入: char型数据
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/
void halRawPut(char c)
{

}



/*---------------------------------------------------------------------------
* @名称: halSetChannel
* @概述: 设置2.4GHz下射频模块的通道
* @输入: BYTE channel-通道
* @输出: LRWPAN_STATUS_ENUM枚举类型的状态值
* @备注: 在2.4G下通道已经决定了频率的具体值
*---------------------------------------------------------------------------*/
LRWPAN_STATUS_ENUM halSetChannel(BYTE channel)
{
    if ((channel < 11) || (channel > 26))
        return(LRWPAN_STATUS_PHY_FAILED);

    MCR20A_SetCurrentChannelRequest(channel, MCR20A_PAN);   //默认采用PAN0

    return LRWPAN_STATUS_SUCCESS;
}


/*---------------------------------------------------------------------------
* @名称: halSetRadioIEEEFrequency
* @概述: 设置射频模块的频率和通道
* @输入: BYTE *buf -地址存放首地址
* @输出: 无
* @备注: 1.大端存储地址 ； 2.如果空间紧张可以存放在FLAH中
*---------------------------------------------------------------------------*/

LRWPAN_STATUS_ENUM halSetRadioIEEEFrequency(PHY_FREQ_ENUM frequency, BYTE channel)
{
    //只支持2.4G
    if(PHY_FREQ_2405M != frequency)
        return LRWPAN_STATUS_PHY_FAILED;    //直接退出

    return halSetChannel(channel);
}


/*---------------------------------------------------------------------------
* @名称: halGetProcessorIEEEAddress
* @概述: 从FLASH中获取IEEE地址
* @输入: BYTE *buf -地址存放首地址
* @输出: 无
* @备注: 1.大端存储地址 ； 2.如果空间紧张可以存放在FLAH中
*---------------------------------------------------------------------------*/

void halGetProcessorIEEEAddress(BYTE *buf)
{
    buf[0] = aExtendedAddress_B0;
    buf[1] = aExtendedAddress_B1;
    buf[2] = aExtendedAddress_B2;
    buf[3] = aExtendedAddress_B3;
    buf[4] = aExtendedAddress_B4;
    buf[5] = aExtendedAddress_B5;
    buf[6] = aExtendedAddress_B6;
    buf[7] = aExtendedAddress_B7;
}




/*---------------------------------------------------------------------------
* @名称: halSetRadioIEEEAddress
* @概述: 将IEEE地址设置到MCR20A射频芯片
* @输入: 无
* @输出: 无
* @备注: IEEE地址必须保证每个节点是唯一的
*---------------------------------------------------------------------------*/

void halSetRadioIEEEAddress(void)
{
    BYTE buf[8];
    halGetProcessorIEEEAddress(buf);

    MCR20A_SetLongAddr(buf, MCR20A_PAN);
}

/*---------------------------------------------------------------------------
* @名称: halSetRadioPANID
* @概述: 设置射频芯片的PANID值
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/

void halSetRadioPANID(UINT16 panid)
{
    MCR20A_SetPanId((uint8_t *)&panid, MCR20A_PAN);
}

/*---------------------------------------------------------------------------
* @名称: halSetRadioShortAddr
* @概述: 设置射频芯片的网络地址
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/

void halSetRadioShortAddr(SADDR saddr)
{
    MCR20A_SetShortAddr((uint8_t *)&saddr, MCR20A_PAN);
}



//return value of non-zero indicates failure
//Turn on Radio, initialize for RF mode
//assumes that auto-ack is enabled
//this function based on sppInit example from ChipCon
//also sets the IEEE address
//if listen_flag is true, then radio is configured for
//listen only (no auto-ack, no address recognition)

/*
Eventually, change this so that auto-ack can be configured as
on or off. When Coordinator is trying to start a network,
auto-ack, addr decoding will be off as Coordinator will be doing an energy
scan and detecting PAN collisions, and thus will not be doing
any acking of packets. After the network is started, then
will enable auto-acking.
Routers and End devices will always auto-ack

i
*/



/*---------------------------------------------------------------------------
* @名称: halSetRadioShortAddr
* @概述: 设置射频芯片的网络地址
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/

LRWPAN_STATUS_ENUM halInitRadio(PHY_FREQ_ENUM frequency, BYTE channel, RADIO_FLAGS radio_flags)
{
    LRWPAN_STATUS_ENUM status;

    if(freq_pre != frequency || channel_pre != channel) {
        freq_pre = frequency;

        halSetRadioIEEEAddress();
        //设置射频模块的频率和通道
        status = halSetRadioIEEEFrequency(frequency, channel);
        if (status != LRWPAN_STATUS_SUCCESS)
            return(status);
    }
    //射频模块上电

    //MCR20A_WARMUP();

    if(local_radio_flags.bits.listen_mode != radio_flags.bits.listen_mode) {
        //listen_mode=1开启混乱模式(DEBUG模式)，listen_mode=0为正常模式
        if (radio_flags.bits.listen_mode ) { //DEBUG模式，接收所有数据帧
            MCR20A_SetPromiscuous(TRUE);
        } else {
            //正常模式，只接受特定的数据帧
            MCR20A_SetPromiscuous(FALSE);
        }
        //PAN_COORDINATOR 是否是协调器，协调器接收所有地址的数据，否则只接受自己为目标的数据
        if (radio_flags.bits.pan_coordinator) {
            //设置为PAN_COORDINATOR模式，接收所有地址的数据
            MCR20A_SetMacRole(PAN_COORDINATOR, MCR20A_PAN);
        } else {
            //只接受目标地址为自己的数据
            MCR20A_SetMacRole(PAN_ENDDIVCE, MCR20A_PAN);
        }

        local_radio_flags = radio_flags;  //记录射频模式状态
    }




    return(LRWPAN_STATUS_SUCCESS);
}

#define PIN_CCA   CCA    //CCA is defined in hal.h

//regardless of what happens here, we will try TXONCCA after this returns.


/*---------------------------------------------------------------------------
* @名称: doIEEE_backoff
* @概述: 进行CCA冲突避免
* @输入: 无
* @输出: 无
* @备注: 最好MCR20A硬件初始化时，设置为CCABeforeTx。
*---------------------------------------------------------------------------*/

void  doIEEE_backoff(void)
{
    BYTE be, nb, tmp, rannum;
    UINT32  delay, start_tick;

    be = aMinBE;
    nb = 0;
    do {
        if (be) {
            //do random delay
            tmp = be;
            //compute new delay
            delay = 1;
            while (tmp) {
                delay = delay << 1;  //delay = 2**be;
                tmp--;
            }
            rannum =  halGetRandomByte() & (delay - 1); //rannum will be between 0 and delay-1
            delay = 0;
            while (rannum) {
                delay  += SYMBOLS_TO_MACTICKS(aUnitBackoffPeriod);
                rannum--;
            }//delay = aUnitBackoff * rannum
            //now do backoff
            start_tick = halGetMACTimer();
            while (halMACTimerNowDelta(start_tick) < delay);
        }
        //check CCA
        //检查CCA状态，如果CCA结束，则立即退出
#if 0
        if (PIN_CCA)
            break;
#else

        MCR20Drv_DirectAccessSPIMultiByteRead(IRQSTS2, &mStatusAndControlRegs[PHY_IRQSTS2_INDEX_c], 1);
        if( mStatusAndControlRegs[PHY_IRQSTS2_INDEX_c] & cIRQSTS2_CCA ) {
            //busy
        } else  //CCA检查发现IDLE
            break;
#endif
        nb++;
        be++;
        if (be > aMaxBE) be = aMaxBE;
    } while (nb <= macMaxCSMABackoffs); //最大重试5次，[0,4]
    return;
}


//transmit packet
//hdrlen - header lenth
//hdr - pointer to header data
//plen - payload length
//pload - pointer to payload


/*---------------------------------------------------------------------------
* @名称: halSendPacket
* @概述: 硬件发送数据包
* @输入: BYTE flen-帧长度，BYTE *frm-帧数据的首地址
* @输出: 返回状态
* @备注: flen帧长度不包括2个字节的CRC(射频模块自动添加)
*---------------------------------------------------------------------------*/
#ifdef SEQ_MRK_ENABLE
//采用中断发送，该函数不做数据处理
LRWPAN_STATUS_ENUM halSendPacket(BYTE flen, BYTE *frm)
{
    LRWPAN_STATUS_ENUM res;
    //total length, does not include length byte itself
    //last two bytes are the FCS bytes that are added automatically
    if (flen + PACKET_FOOTER_SIZE > 127) {
        //packet size is too large!
        res = LRWPAN_STATUS_PHY_TX_PKT_TOO_BIG;
    } else {
        res = LRWPAN_STATUS_SUCCESS;
        phyTxStartCallBack();
        //EVB_LED1_ON();
    }
    return(res);
}

#else
LRWPAN_STATUS_ENUM halSendPacket(BYTE flen, BYTE *frm)
{
    BYTE len;
    LRWPAN_STATUS_ENUM res;
    BYTE phyReg;

    BYTE tmpbuf[LRWPAN_MAX_FRAME_SIZE + 1]; //maximum payload size
    BYTE *ptr;
    BYTE seqState = 0;

    EVB_LED1_ON();

    //total length, does not include length byte itself
    //last two bytes are the FCS bytes that are added automatically
    if (flen + PACKET_FOOTER_SIZE > 127) {
        //packet size is too large!
        return(LRWPAN_STATUS_PHY_TX_PKT_TOO_BIG);
    }

    ptr = &tmpbuf[0];
    *ptr = flen + PACKET_FOOTER_SIZE; //length does not include length byte
    ptr++;
    //copy frame
    memcpy(ptr, frm, flen);
    ptr = ptr + flen;

    //关闭MCU中断，不处理MCR20内存中断寄存器
    MCR20Drv_IRQ_Disable();
    MCR20Drv_IRQ_Clear();

    seqState = MCR20Drv_DirectAccessSPIRead(SEQ_STATE) & 0x1F;
    if(seqState != 0) {
        phyReg = MCR20Drv_DirectAccessSPIRead(PHY_CTRL1);
        phyReg &= ~(cPHY_CTRL1_XCVSEQ);
        phyReg |= gIdle_c;
        MCR20Drv_DirectAccessSPIWrite( PHY_CTRL1, phyReg);
    }
    do {
        seqState = MCR20Drv_DirectAccessSPIRead(SEQ_STATE) & 0x1F;
        //等待空闲
    } while (seqState != 0);



    //写数据到射频芯片
    MCR20Drv_PB_SPIBurstWrite(tmpbuf, flen + 1);

    /* 启动TX时序 ，开启CCABFRTX*/
    phyReg = MCR20Drv_DirectAccessSPIRead(PHY_CTRL1);
    phyReg &= ~(cPHY_CTRL1_XCVSEQ);
    phyReg |= gTX_c;
    MCR20Drv_DirectAccessSPIWrite( PHY_CTRL1, phyReg);


    MCR20Drv_IRQ_Enable();

    return(LRWPAN_STATUS_SUCCESS);
}


#endif

#ifdef  LRWPAN_ASYNC_INTIO

/*---------------------------------------------------------------------------
* @名称: urx0_service_IRQ
* @概述: UART0中断服务程序
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/
INTERRUPT_FUNC urx0_service_IRQ(void)
{

    BYTE x, y;

    serio_rxHead++;
    if (serio_rxHead == LRWPAN_ASYNC_RX_BUFSIZE ) serio_rxHead = 0;
    x = serio_rxHead;  //use tmp variables because of Volatile decl
    //y = U0DBUF; //获取数据
    serio_rxBuff[x] = y;
}

#endif



//This timer interrupt is the periodic interrupt for
//evboard functions

#undef LRWPAN_ENABLE_SLOW_TIMER
#ifdef LRWPAN_ENABLE_SLOW_TIMER


// assuming 16us period, have 1/16us = 62500 tics per seocnd
#define T2CMPVAL (62500/SLOWTICKS_PER_SECOND)

/*---------------------------------------------------------------------------
* @名称: t2_service_IRQ
* @概述: T2中断服务程序，任务调度使用
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/
INTERRUPT_FUNC t2_service_IRQ(void)
{
    UINT32 t;

    INT_GLOBAL_ENABLE(INT_OFF);
    INT_SETFLAG_T2(INT_CLR); //clear processor interrupt flag
    //compute next compare value by reading current timer value, adding offset
    t = 0x0FF & T2OF0;
    t += (((UINT16)T2OF1) << 8);
    t += (((UINT32) T2OF2 & 0x0F) << 16);
    t += T2CMPVAL;  //add offset
    T2PEROF0 = t & 0xFF;
    T2PEROF1 = (t >> 8) & 0xFF;
    //enable overflow count compare interrupt
    T2PEROF2 = ((t >> 16) & 0x0F) | 0x20;
    T2CNF = 0x03; //this clears the timer2 flags
    evbIntCallback();  //Evaluation board callback
    usrSlowTimerInt();  //user level interrupt callback
    INT_GLOBAL_ENABLE(INT_ON);
}
#endif





/*---------------------------------------------------------------------------
* @名称: rf_error_IRQ
* @概述: 射频模块错误中断服务程序
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/

INTERRUPT_FUNC rf_error_IRQ(void)
{
#if 0
    INT_GLOBAL_ENABLE(INT_OFF);

    // If Rx overflow occurs, the Rx FiFo is reset.
    // The Rx DMA is reset and reception is started over.
    if(FSMSTATE == 17) {
        DEBUG_CHAR( DBG_ITRACE, DBG_CHAR_TXBUSY);
        STOP_RADIO();
        ISFLUSHRX;
        ISFLUSHRX;
        ISRXON;
    } else if(FSMSTATE == 56) {
        DEBUG_CHAR( DBG_ITRACE, DBG_CHAR_RXOFLOW);
        ISFLUSHTX;
    }

    INT_SETFLAG_RFERR(INT_CLR);

    INT_GLOBAL_ENABLE(INT_ON);
#endif
}

//发送空闲状态，置射频模块为接收状态
void  halIdle()
{
    BYTE phyReg = 0;
    BYTE seqState = 0;
    phyTime_t timeOut = 0;
    seqState = MCR20Drv_DirectAccessSPIRead(SEQ_STATE) & 0x1F;



    //射频芯片正常工作起来是应该一直处于RX或TX状态，只有在中断处理函数中会处于空闲
    //万一芯片处于空闲但是又没有进入中断函数则需要该代码将其置为RX状态，并触发中断函数
    if(0 == seqState) {
//启动T3计时器，用于硬件自动超时退出RX时序

        MCR20Drv_DirectAccessSPIMultiByteRead(EVENT_TMR_LSB, (BYTE *) &timeOut, 3);
        timeOut += RX_TIMEOUT;
        timeOut &= 0x0FFFFFF;
        MCR20Drv_DirectAccessSPIMultiByteWrite( T3CMP_LSB, (BYTE *) &timeOut, 3);
        /* enable autosequence stop by TC3 match */
        mStatusAndControlRegs[PHY_CTRL4_INDEX_c] |= cPHY_CTRL4_TC3TMOUT;
        MCR20Drv_DirectAccessSPIWrite(PHY_CTRL4, mStatusAndControlRegs[PHY_CTRL4_INDEX_c]);

        //进入RX时序
        phyReg = mStatusAndControlRegs[PHY_CTRL1_INDEX_c];
        phyReg &= ~(cPHY_CTRL1_XCVSEQ);
        phyReg |= gRX_c ;
        MCR20Drv_DirectAccessSPIWrite( PHY_CTRL1, phyReg);
    }
}



void evbPoll()
{

}


void halRadioGetFrame(BYTE flen)
{

    BYTE ack_bytes[LRWPAN_ACKFRAME_LENGTH];
    BYTE rssi = 0;
    BYTE *ptr, *rx_frame;

    BYTE delayTmp = 50;

    if(0 == flen || flen > 127)   //非法长度，直接退出
        return ;

    if(LRWPAN_ACKFRAME_LENGTH == flen) {
        //ACK
        ack_bytes[0] = flen;
        //MCR20A缓冲中CRC2字节硬件自动校验，不需要读取,实际读取长度flen-2
        MCR20Drv_PB_SPIBurstRead( (uint8_t *)(ack_bytes + 1), flen - 2);
        macRxCallback(ack_bytes, ack_bytes[4]);
    } else {

        if (!macRxBuffFull()) {
            //MAC TX buffer has room
            //allocate new memory space
            //read the length
            rx_frame = MemAlloc(flen + 1);
            //memset(rx_frame, 0, flen + 1);
            ptr = rx_frame;
        } else {
            //MAC RX buffer is full
            DEBUG_CHAR( DBG_ITRACE, DBG_CHAR_MACFULL );
        }
        if (ptr == NULL) {
            //无内存，不处理
        } else {
            //添加数据长度，1个字节
            *ptr = flen;
            ptr++;
            //MCR20A缓冲中CRC2字节硬件自动校验，不需要读取,实际读取长度flen-2
            MCR20Drv_PB_SPIBurstRead( (uint8_t *)(ptr), flen - 2);


            rssi = MCR20Drv_DirectAccessSPIRead(LQI_VALUE);
            if(0 == rssi) {
                while(delayTmp--);        //等待一段时间，具体多少时间有待验证
                rssi = MCR20Drv_DirectAccessSPIRead(LQI_VALUE);
            }
            //将RSSI值从2的次方表示转换成 0~0XFF的数值 MCR20Drv_DirectAccessSPIRead(LQI_VALUE);不需要再处理
            rssi = MCR20A_LqiConvert(rssi);

            //处理PHY回调函数
            phyRxCallback();
            macRxCallback(rx_frame, rssi);
        }
    }
}
#if 1 //def SEQ_MRK_ENABLE
//cPHY_CTRL2_SEQMSK开启SEQ中断，采用中断收发
//不能接收到ACK(ACK发送间隔在10ms之内，由硬件自动发送，接收响应不过来)
void IRQ_Handler()
{

    BYTE xcvseq = 0;
    BYTE *ptr;
    BYTE tmpbuf[LRWPAN_MAX_FRAME_SIZE + 1]; //maximum payload size
    BYTE phyReg = 0, seqNext = gRX_c;
    BYTE t3timeOutEnable = 1; //T3 使能
    BYTE flen = 0;
    phyTime_t timeOut = 0;

    /* Disable and clear transceiver(IRQ_B) interrupt */
    MCR20Drv_IRQ_Disable();
    MCR20Drv_IRQ_Clear();

    count++;
    if(count % 5 == 0) {
        EVB_LED1_OFF();
    } else {
        EVB_LED1_ON();
    }

    mStatusAndControlRegs[PHY_IRQSTS1_INDEX_c] =
        MCR20Drv_DirectAccessSPIMultiByteRead(IRQSTS2, &mStatusAndControlRegs[PHY_IRQSTS2_INDEX_c], 7);
    //清中断标志
    MCR20Drv_DirectAccessSPIMultiByteWrite(IRQSTS1, mStatusAndControlRegs, 3);

    //获取当前中断类型
    halUtilMemCopy((BYTE *)&irq, mStatusAndControlRegs, 1);
    //获取当前时序控制器的状态
    xcvseq = mStatusAndControlRegs[PHY_CTRL1_INDEX_c] & cPHY_CTRL1_XCVSEQ;

    //保存数据长度
    flen = mStatusAndControlRegs[PHY_RX_FRM_LEN_INDEX_c];

    //保存时序状态
    phyReg = mStatusAndControlRegs[PHY_CTRL1_INDEX_c];
    phyReg &= ~(cPHY_CTRL1_XCVSEQ);

    //debug调试使用
    if(LRWPAN_ACKFRAME_LENGTH == flen) {
        flen = 5;
    }

    //如果接收标志有效表示一个完整的数据包接收完成，直接处理
    if(irq.rx) {
        halRadioGetFrame(flen);
        //启动接收时序
        seqNext = gRX_c ;
    }
    //!irq.rx 且 irq.rxWaterMark
    else if(irq.rxWaterMark) {
        //关闭SEQ中断，只响应rxWaterMark中断
        mStatusAndControlRegs[PHY_CTRL2_INDEX_c] |= cPHY_CTRL2_SEQMSK;
        MCR20Drv_DirectAccessSPIWrite(PHY_CTRL2, mStatusAndControlRegs[PHY_CTRL2_INDEX_c]);
        //关闭T3接收终止RX功能
        t3timeOutEnable = 0;


        if(0 == rxWaterMark) {    //
            if(gRX_c == xcvseq || gTR_c == xcvseq) {
                if(irq.seq) { //接收到一个完整的数据帧

                    halRadioGetFrame(flen);

                    //开启SEQ中断，响应SEQ和rxWaterMark中断
                    mStatusAndControlRegs[PHY_CTRL2_INDEX_c] &= ~cPHY_CTRL2_SEQMSK;
                    MCR20Drv_DirectAccessSPIWrite(PHY_CTRL2, mStatusAndControlRegs[PHY_CTRL2_INDEX_c]);
                    //开启T3终止RX功能
                    t3timeOutEnable = 1;

                    if(phyState == PHY_STATE_TX_WAIT) { //有数据需要发送，启动发送时序
                        ptr = &tmpbuf[0];
                        *ptr = phy_pib.currentTxFlen + PACKET_FOOTER_SIZE; //length does not include length byte
                        ptr++;
                        //copy frame
                        memcpy(ptr, phy_pib.currentTxFrm, phy_pib.currentTxFlen);

                        //写数据到射频芯片
                        MCR20Drv_PB_SPIBurstWrite(tmpbuf, phy_pib.currentTxFlen + 1);
                        /* 启动TX时序 ，开启CCABFRTX*/
                        seqNext = gTX_c ;

                    } else {
                        //启动接收时序
                        seqNext = gRX_c ;

                    }

                } else { //只收到一个帧头，重写WATERMARK
                    rxWaterMark = flen - 2;
                    MCR20Drv_IndirectAccessSPIWrite(RX_WTR_MARK, rxWaterMark);

                    MCR20Drv_IRQ_Enable();
                    return ;    //直接退出等待下一个 RXWATERMKIRQ或RXIRQ
                }
            }
        } else {  //接收到完整的数据帧

            //设置RXwatermark为0
            rxWaterMark = 0;
            MCR20Drv_IndirectAccessSPIWrite(RX_WTR_MARK, rxWaterMark);

            halRadioGetFrame(flen);

            //开启SEQ中断，响应SEQ和rxWaterMark中断
            mStatusAndControlRegs[PHY_CTRL2_INDEX_c] &= ~cPHY_CTRL2_SEQMSK;
            MCR20Drv_DirectAccessSPIWrite(PHY_CTRL2, mStatusAndControlRegs[PHY_CTRL2_INDEX_c]);

            seqNext = gRX_c ;
        }
    }
    //irq.seq且 !irq.rxWaterMark （irq.rx 可能为1，也可能为0）
    if(irq.seq && !irq.rxWaterMark) {

        switch(xcvseq) {
            case gTX_c:
                if(phyState == PHY_STATE_TX_WAIT) {
                    //发送结束执行回调函数
                    phyTxEndCallBack();
                    macTxCallback();                 
                }
                //进入RX时序
                seqNext = gRX_c ;

                break;
            case gRX_c:


                if(phyState == PHY_STATE_TX_WAIT) { //有数据需要发送，启动发送时序
                    ptr = &tmpbuf[0];
                    *ptr = phy_pib.currentTxFlen + PACKET_FOOTER_SIZE; //length does not include length byte
                    ptr++;
                    //copy frame
                    memcpy(ptr, phy_pib.currentTxFrm, phy_pib.currentTxFlen);

                    //写数据到射频芯片
                    MCR20Drv_PB_SPIBurstWrite(tmpbuf, phy_pib.currentTxFlen + 1);
                    /* 启动TX时序 ，开启CCABFRTX*/
                    seqNext = gTX_c ;

                } else {
                    //启动接收时序
                    seqNext = gRX_c ;
                }

                break;
            //case gCCA_c:    //开启CCABFRTX后，CCA完成后会自动进入TX，程序不会设置时序为CCA
            //因此该状态不会发生，不做任何处理
            //  break;
            default:    //其他时序不处理
                seqNext = gRX_c ;

                break;
        }
    }
    //RX时序且T3终止功能打开
    if(gRX_c == seqNext && t3timeOutEnable) {
        //启动T3计时器，用于硬件自动超时退出RX时序

        MCR20Drv_DirectAccessSPIMultiByteRead(EVENT_TMR_LSB, (BYTE *) &timeOut, 3);
        timeOut += RX_TIMEOUT;
        timeOut &= 0x0FFFFFF;
        MCR20Drv_DirectAccessSPIMultiByteWrite( T3CMP_LSB, (BYTE *) &timeOut, 3);
        /* enable autosequence stop by TC3 match */
        mStatusAndControlRegs[PHY_CTRL4_INDEX_c] |= cPHY_CTRL4_TC3TMOUT;
        MCR20Drv_DirectAccessSPIWrite(PHY_CTRL4, mStatusAndControlRegs[PHY_CTRL4_INDEX_c]);
    }
    phyReg |= seqNext ;
    MCR20Drv_DirectAccessSPIWrite( PHY_CTRL1, phyReg);


    MCR20Drv_IRQ_Enable();

}

#else
void IRQ_Handler()
{

    BYTE xcvseq = 0;
    BYTE *ptr;
    BYTE tmpbuf[LRWPAN_MAX_FRAME_SIZE + 1]; //maximum payload size
    BYTE phyReg = 0;
    BYTE flen = 0;
    phyTime_t timeOut = 0;

    /* Disable and clear transceiver(IRQ_B) interrupt */
    MCR20Drv_IRQ_Disable();
    MCR20Drv_IRQ_Clear();

    count++;
    if(count % 5 == 0) {
        EVB_LED1_OFF();
    } else {
        EVB_LED1_ON();
    }

    mStatusAndControlRegs[PHY_IRQSTS1_INDEX_c] =
        MCR20Drv_DirectAccessSPIMultiByteRead(IRQSTS2, &mStatusAndControlRegs[PHY_IRQSTS2_INDEX_c], 7);
    //清中断标志
    MCR20Drv_DirectAccessSPIMultiByteWrite(IRQSTS1, mStatusAndControlRegs, 3);

    //获取当前中断类型
    halUtilMemCopy((BYTE *)&irq, mStatusAndControlRegs, 1);
    //获取当前时序控制器的状态
    xcvseq = mStatusAndControlRegs[PHY_CTRL1_INDEX_c] & cPHY_CTRL1_XCVSEQ;

    //保存数据长度
    flen = mStatusAndControlRegs[PHY_RX_FRM_LEN_INDEX_c];
    if(LRWPAN_ACKFRAME_LENGTH == flen) {
        flen = 5;
    }
    if(irq.rx) {
        halRadioGetFrame(flen);
        //进入RX时序
        phyReg = mStatusAndControlRegs[PHY_CTRL1_INDEX_c];
        phyReg &= ~(cPHY_CTRL1_XCVSEQ);
        phyReg |= gRX_c ;
        MCR20Drv_DirectAccessSPIWrite( PHY_CTRL1, phyReg);
    } else if(irq.rxWaterMark) {

        if(0 == rxWaterMark) {    //
            if(gRX_c == xcvseq || gTR_c == xcvseq) {
                if(irq.seq) { //接收到一个完整的数据帧

                    halRadioGetFrame(flen);
                    //进入RX时序
                    phyReg = mStatusAndControlRegs[PHY_CTRL1_INDEX_c];
                    phyReg &= ~(cPHY_CTRL1_XCVSEQ);
                    phyReg |= gRX_c ;
                    MCR20Drv_DirectAccessSPIWrite( PHY_CTRL1, phyReg);


                } else { //只收到一个帧头，重写WATERMARK
                    rxWaterMark = flen - 2;
                    MCR20Drv_IndirectAccessSPIWrite(RX_WTR_MARK, rxWaterMark);

                }
            }
        } else {  //接收到完整的数据帧

            //设置RXwatermark为0
            rxWaterMark = 0;
            MCR20Drv_IndirectAccessSPIWrite(RX_WTR_MARK, rxWaterMark);

            halRadioGetFrame(flen);

            //进入RX时序
            phyReg = mStatusAndControlRegs[PHY_CTRL1_INDEX_c];
            phyReg &= ~(cPHY_CTRL1_XCVSEQ);
            phyReg |= gRX_c ;
            MCR20Drv_DirectAccessSPIWrite( PHY_CTRL1, phyReg);
        }
    }

    else if(irq.tx) {
        if(phyState == PHY_STATE_TX_WAIT) {
            //发送结束执行回调函数
            phyTxEndCallBack();
            macTxCallback();
        }
        //进入RX时序
        phyReg = mStatusAndControlRegs[PHY_CTRL1_INDEX_c];
        phyReg &= ~(cPHY_CTRL1_XCVSEQ);
        phyReg |= gRX_c ;
        MCR20Drv_DirectAccessSPIWrite( PHY_CTRL1, phyReg);
    }

    MCR20Drv_IRQ_Enable();

}
#endif
//This interrupt used for both TX and RX

/*---------------------------------------------------------------------------
* @名称: RADIO_IRQ_Handler
* @概述: 射频模块RX中断服务程序
* @输入: 无
* @输出: 无
* @备注: 射频模块只需要打开RX_IRQ
*---------------------------------------------------------------------------*/
INTERRUPT_FUNC RADIO_IRQ_Handler(void)
{

    BYTE flen = 0;
    BYTE enabledAndActiveInterrupt = 0;
    BYTE *ptr, *rx_frame;
    BYTE ack_bytes[5];

    UINT8 xcvseq = 0;
    BYTE phyReg = 0;

    BYTE mPhyWatermarkLevel = 0;
    BYTE byteCount = 0;

    enum {
        SEQ_IDLE = 0,
        SEQ_RX,
        SEQ_TX,
        SEQ_CCA,
        SEQ_CCCA
    };

    UINT8 rssi = 0; //保存RSSI值

    EVB_LED1_ON();

    /* Disable and clear transceiver(IRQ_B) interrupt */
    MCR20Drv_IRQ_Disable();
    MCR20Drv_IRQ_Clear();

    //等待接收时序结束
    do {
        mStatusAndControlRegs[PHY_IRQSTS1_INDEX_c] =
            MCR20Drv_DirectAccessSPIMultiByteRead(IRQSTS2, &mStatusAndControlRegs[1], 7);
    } while((mStatusAndControlRegs[PHY_IRQSTS1_INDEX_c] & 0x01 ) == 0);


    /* clear transceiver interrupts */
    MCR20Drv_DirectAccessSPIMultiByteWrite(IRQSTS1, mStatusAndControlRegs, 3);
    //保存数据长度
    flen = mStatusAndControlRegs[PHY_RX_FRM_LEN_INDEX_c];
    //没有获取到有效的数据，直接退出，不处理
    if(flen == 0 || flen > 127)
        goto EndMCR20AIrq;


    //数据有效长度不超过127
    if ( flen <= 127) {

        if(LRWPAN_ACKFRAME_LENGTH == flen) {
            //ACK
            ack_bytes[0] = flen;    //只处理BYTE[0]标识为ACK数据包，不需要所有的ACK数据
            //ack_bytes[4]=MCR20Drv_DirectAccessSPIRead(LQI_VALUE);
            macRxCallback(ack_bytes, ack_bytes[4]);
            enabledAndActiveInterrupt = 1;
        } else {

            if (!macRxBuffFull()) {
                //MAC TX buffer has room
                //allocate new memory space
                //read the length
                rx_frame = MemAlloc(flen + 1);
                //memset(rx_frame, 0, flen + 1);
                ptr = rx_frame;
            } else {
                //MAC RX buffer is full
                DEBUG_CHAR( DBG_ITRACE, DBG_CHAR_MACFULL );
            }
            if (ptr == NULL) {
                //无内存，不处理
            } else {
                //添加数据长度，1个字节
                *ptr = flen;
                ptr++;
                //MCR20A缓冲中CRC2字节硬件自动校验，不需要读取,实际读取长度flen-2
                MCR20Drv_PB_SPIBurstRead( (uint8_t *)(ptr), flen - 2);

                //处理MAC接收回调
                rssi = MCR20Drv_DirectAccessSPIRead(LQI_VALUE);
                //将RSSI值从2的次方表示转换成 0~0XFF的数值 MCR20Drv_DirectAccessSPIRead(LQI_VALUE);不需要再处理
                rssi = MCR20A_LqiConvert(rssi);

                //处理PHY回调函数
                phyRxCallback();
                macRxCallback(rx_frame, rssi);
            }
        }


    }

    // Transmission of a packet is finished. Enabling reception of ACK if required.
    if(enabledAndActiveInterrupt) {
        //Finished TX, do call back
        DEBUG_CHAR( DBG_ITRACE, DBG_CHAR_TXFIN );
        phyTxEndCallBack();
        macTxCallback();
    }

    usrIntCallback();

EndMCR20AIrq:


    //清SEQ中断标志寄存器
    MCR20A_IsrSeqCleanup();
#if 0
    /* 启动RX时序 */
    phyReg = MCR20Drv_DirectAccessSPIRead(PHY_CTRL1);
    if(phyReg & cPHY_CTRL1_XCVSEQ) {
        phyReg &= ~(cPHY_CTRL1_XCVSEQ);
        phyReg |= gIdle_c;
        MCR20Drv_DirectAccessSPIWrite( PHY_CTRL1, phyReg);
    }
#endif
    MCR20Drv_IRQ_Enable();
}



//software delay, waits is in milliseconds
/*---------------------------------------------------------------------------
* @名称: halWait
* @概述: 软件延迟(单位:0.01ms)
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/
void halWait(BYTE wait)
{
    UINT32 largeWait = 1;

    if(wait == 0) {
        return;
    }
#if 0
    largeWait = ((UINT16) (wait << 7));
    largeWait += 114 * wait;


    largeWait = (largeWait >> CLKSPD);
#else
    //计算一个延迟值，保证延迟单位在0.01ms
#endif

    while(largeWait--);

    return;
}

/*---------------------------------------------------------------------------
* @名称: halWaitMs
* @概述: 软件延迟(单位:ms)
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/
void halWaitMs(const UINT32 msecs)
{
    UINT32 towait;

    towait = msecs;
    while (towait > 100) {
        halWait(100);
        towait -= 100;
    }
    halWait(towait);
}


/*---------------------------------------------------------------------------
* @名称: halShutdown
* @概述: 关闭
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/

void halShutdown(void)
{
    //disable some interrupts
#ifdef LRWPAN_ENABLE_SLOW_TIMER
    INT_ENABLE_T2(INT_OFF);
#endif

    //关闭MCR20A中断
    //清零MCR20A中断
    //将MCR20A设置为IDLE状态
    MCR20A_Abort();

}


/*---------------------------------------------------------------------------
* @名称: halWarmstart
* @概述: 射频模块热启动
* @输入: 无
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/

void halWarmstart(void)
{
#if 0
    UINT32 myticks;
    //re-enable the timer interrupt
#ifdef LRWPAN_ENABLE_SLOW_TIMER
    INT_ENABLE_T2(INT_ON);
#endif
    //turn on the radio again
    RFPWR = RFPWR & ~(1 << 3);  //RFPWR.RREG_RADIO_PD = 0;
    //wait for power to stabilize
    myticks = halGetMACTimer();
    while (halMACTimerNowDelta(myticks) < MSECS_TO_MACTICKS(10)) {
        //check the power up bit, max time is supposed to be 2 ms
        if (!(RFPWR & ~(1 << 4))) break;
    }

#endif
}




/*---------------------------------------------------------------------------
* @名称: halSleep
* @概述: 射频模块休眠
* @输入: UINT32 msecs-休眠时间
* @输出: 无
* @备注:
*---------------------------------------------------------------------------*/

void halSleep(UINT32 msecs)
{
    //判定射频模块是否处于IDLE状态
    //如果是IDLE则进入休眠

    //关闭所有中断(射频相关)
    //清中断标志

    //设置射频模块的休眠定时器

    //设置射频模块为低功耗模式

    //打开射频模块的中断

}


